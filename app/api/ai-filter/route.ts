import { NextRequest, NextResponse } from 'next/server';
import Groq from 'groq-sdk';

// Initialize Groq client
const groq = new Groq({
  apiKey: process.env.GROQ_API_KEY!,
});

type EntityType = 'tasks' | 'clients' | 'workers';

interface AIQueryRequest {
  query: string;
  data: any[];
  entity?: EntityType;
}

export async function POST(req: NextRequest) {
  console.log('AI Filter API POST called');
  
  // Add CORS headers
  const headers = {
    'Access-Control-Allow-Origin': '*',
    'Access-Control-Allow-Methods': 'POST, OPTIONS',
    'Access-Control-Allow-Headers': 'Content-Type',
    'Content-Type': 'application/json',
  };

  try {
    // Check if GROQ_API_KEY is available
    if (!process.env.GROQ_API_KEY) {
      console.error('GROQ_API_KEY is not set');
      return NextResponse.json(
        { error: 'API configuration error: GROQ_API_KEY not found. Please set GROQ_API_KEY in your .env.local file.' },
        { status: 500, headers }
      );
    }

    let body: AIQueryRequest;
    
    try {
      body = await req.json();
    } catch (parseError) {
      console.error('JSON parse error:', parseError);
      return NextResponse.json(
        { error: 'Invalid JSON in request body' },
        { status: 400, headers }
      );
    }

    const { query, data, entity } = body;

    console.log('AI Filter API called with:', { 
      query: query?.substring(0, 100), 
      dataLength: data?.length, 
      entity 
    });

    // Validate required fields
    if (!query || typeof query !== 'string') {
      return NextResponse.json(
        { error: 'Query is required and must be a string' },
        { status: 400, headers }
      );
    }

    if (!data || !Array.isArray(data)) {
      return NextResponse.json(
        { error: 'Data is required and must be an array' },
        { status: 400, headers }
      );
    }

    if (data.length === 0) {
      return NextResponse.json({
        filtered: [],
        condition: 'No data to filter',
        originalCount: 0,
        filteredCount: 0
      }, { headers });
    }

    // Get entity type and create context
    const entityType = entity || 'items';
    const contextExample = JSON.stringify(data.slice(0, 2), null, 2);

    const prompt = `You are a TypeScript AI assistant. Given a list of ${entityType}, generate a JavaScript filter condition to filter the array based on the user's natural language query.

Data Sample:
${contextExample}

User Query: "${query}"

IMPORTANT: Return ONLY the JavaScript condition that goes inside a filter function. Do not include "function", "return", or any other wrapper code.

Examples based on typical task data:
- For "tasks with duration greater than 5": item.Duration > 5
- For "tasks that require JavaScript skill": item.RequiredSkills && item.RequiredSkills.includes('JavaScript')
- For "tasks in phase 2": item.PreferredPhases && item.PreferredPhases.includes(2)
- For "tasks with name containing test": item.TaskName && item.TaskName.toLowerCase().includes('test')

Your condition:`;

    let groqResponse;
    try {
      console.log('Calling Groq API...');
      groqResponse = await groq.chat.completions.create({
        model: 'llama3-8b-8192',
        messages: [
          {
            role: 'system',
            content: 'You generate JavaScript filter conditions for array filtering based on natural language. Return only the condition, no explanations.'
          },
          { role: 'user', content: prompt },
        ],
        temperature: 0.1,
        max_tokens: 200,
      });
      console.log('Groq API call successful');
    } catch (groqError) {
      console.error('Groq API error:', groqError);
      return NextResponse.json(
        { 
          error: 'AI service unavailable', 
          details: groqError instanceof Error ? groqError.message : 'Unknown AI error'
        },
        { status: 503, headers }
      );
    }

    const condition = groqResponse.choices?.[0]?.message?.content?.trim();

    if (!condition) {
      return NextResponse.json(
        { error: 'No condition generated by AI' },
        { status: 500, headers }
      );
    }

    console.log('Generated condition:', condition);

    // Create and execute filter function safely
    let filtered: any[];
    try {
      // Create a more robust filter function with better error handling
      const filterFunction = new Function('item', `
        try {
          // Add null/undefined checks for common properties
          if (!item) return false;
          
          return ${condition};
        } catch (e) {
          console.warn('Filter condition error for item:', item, e.message);
          return false;
        }
      `) as (item: any) => boolean;

      filtered = data.filter(filterFunction);
    } catch (functionError) {
      console.error('Error creating/executing filter function:', functionError);
      return NextResponse.json(
        {
          error: 'Invalid filter condition generated',
          condition,
          details: functionError instanceof Error ? functionError.message : 'Unknown error'
        },
        { status: 400, headers }
      );
    }

    const result = {
      filtered,
      condition,
      originalCount: data.length,
      filteredCount: filtered.length
    };

    console.log('Filter results:', {
      originalCount: result.originalCount,
      filteredCount: result.filteredCount,
      condition: result.condition
    });

    return NextResponse.json(result, { headers });

  } catch (error) {
    console.error('AI Filter API unexpected error:', error);
    return NextResponse.json(
      {
        error: 'Failed to process AI query',
        details: error instanceof Error ? error.message : 'Unknown server error'
      },
      { status: 500, headers }
    );
  }
}

// Handle preflight requests
export async function OPTIONS(req: NextRequest) {
  console.log('AI Filter API OPTIONS called');
  return new NextResponse(null, {
    status: 200,
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type',
    },
  });
}

// Add a GET method for testing
export async function GET() {
  return NextResponse.json({ 
    message: 'AI Filter API is working!',
    timestamp: new Date().toISOString()
  });
}